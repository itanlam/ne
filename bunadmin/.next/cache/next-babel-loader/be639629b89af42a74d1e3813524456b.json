{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport rxDb from \"@/utils/database/rxConnect\";\nimport { Collection } from \"../collections\";\nimport { Primary } from \"../schema\";\nimport { CoreGroupName } from \"@/utils/routes\";\nimport { notice } from \"@/core\";\nexport function editableController() {\n  const collection = Collection.name;\n  const primary = Primary;\n\n  const nanoId = require(\"nanoid\")(10);\n\n  const created_at = {\n    created_at: Date.now()\n  };\n  const updated_at = {\n    updated_at: Date.now()\n  };\n\n  async function checkGroup(group) {\n    if (group === CoreGroupName) {\n      // show notice\n      await notice({\n        title: `Created failed`,\n        severity: \"error\",\n        content: \"Group name can't be `core`\"\n      });\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  return {\n    // isEditable: rowData => rowData.not_editable === true, // only name(a) rows would be editable\n    // isDeletable: rowData => rowData.not_deletable === true, // only name(a) rows would be deletable\n    onRowAdd: newData => new Promise(async resolve => {\n      // check group\n      if (await checkGroup(newData.group)) {\n        return resolve();\n      }\n\n      try {\n        const db = await rxDb();\n        await db[collection].insert(_objectSpread(_objectSpread({\n          // @ts-ignore\n          [primary]: nanoId\n        }, newData), {}, {\n          customized: newData.customized === \"true\"\n        }, created_at)); // show notice\n\n        await notice({\n          title: `Created successful`\n        });\n      } catch (e) {\n        console.error(e); // console.log(e.parameters.errors.toString())\n        // show notice\n\n        await notice({\n          title: `Created failed`,\n          severity: \"error\",\n          content: e.toString()\n        });\n      }\n\n      resolve();\n    }),\n    onRowUpdate: newData => new Promise(async resolve => {\n      // check group\n      if (await checkGroup(newData.group)) {\n        return resolve();\n      }\n\n      try {\n        const db = await rxDb();\n        const query = db[collection].findOne().where(primary).eq(newData[primary]);\n        await query.update({\n          $set: _objectSpread(_objectSpread({}, newData), {}, {\n            customized: newData.customized === \"true\"\n          }, updated_at)\n        }); // show notice\n\n        await notice({\n          title: `Updated successful`\n        });\n      } catch (e) {\n        console.error(e); // show notice\n\n        await notice({\n          title: `Updated failed`,\n          severity: \"error\",\n          content: e.toString()\n        });\n      }\n\n      resolve();\n    }),\n    onRowDelete: oldData => new Promise(async resolve => {\n      try {\n        const db = await rxDb();\n        const query = db[collection].findOne().where(primary).eq(oldData[primary]);\n        await query.remove(); // show notice\n\n        await notice({\n          title: `Deleted successful`\n        });\n      } catch (e) {\n        console.error(e); // show notice\n\n        await notice({\n          title: `Deleted failed`,\n          severity: \"error\",\n          content: e.toString()\n        });\n      }\n\n      resolve();\n    })\n  };\n}","map":{"version":3,"sources":["/Volumes/Untitled/GitHub/itanlam/ne/bunadmin/src/core/schema/controllers/editableController.tsx"],"names":["rxDb","Collection","Primary","CoreGroupName","notice","editableController","collection","name","primary","nanoId","require","created_at","Date","now","updated_at","checkGroup","group","title","severity","content","onRowAdd","newData","Promise","resolve","db","insert","customized","e","console","error","toString","onRowUpdate","query","findOne","where","eq","update","$set","onRowDelete","oldData","remove"],"mappings":"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","sourcesContent":["import rxDb from \"@/utils/database/rxConnect\"\nimport { EditableDataType } from \"@/components/CommonTable/models/editable\"\nimport { Type } from \"../types\"\nimport { Collection } from \"../collections\"\nimport { Primary } from \"../schema\"\nimport { CoreGroupName } from \"@/utils/routes\"\nimport { notice } from \"@/core\"\n\nexport function editableController(): EditableDataType<Type> {\n  const collection = Collection.name\n  const primary = Primary\n\n  const nanoId = require(\"nanoid\")(10)\n  const created_at = { created_at: Date.now() }\n  const updated_at = { updated_at: Date.now() }\n\n  async function checkGroup(group: string) {\n    if (group === CoreGroupName) {\n      // show notice\n      await notice({\n        title: `Created failed`,\n        severity: \"error\",\n        content: \"Group name can't be `core`\"\n      })\n      return true\n    } else {\n      return false\n    }\n  }\n\n  return {\n    // isEditable: rowData => rowData.not_editable === true, // only name(a) rows would be editable\n    // isDeletable: rowData => rowData.not_deletable === true, // only name(a) rows would be deletable\n    onRowAdd: newData =>\n      new Promise(async resolve => {\n        // check group\n        if (await checkGroup(newData.group)) {\n          return resolve()\n        }\n\n        try {\n          const db = await rxDb()\n\n          await db[collection].insert({\n            // @ts-ignore\n            [primary]: nanoId,\n            ...newData,\n            customized: ((newData.customized as unknown) as string) === \"true\",\n            ...created_at\n          })\n\n          // show notice\n          await notice({ title: `Created successful` })\n        } catch (e) {\n          console.error(e)\n          // console.log(e.parameters.errors.toString())\n\n          // show notice\n          await notice({\n            title: `Created failed`,\n            severity: \"error\",\n            content: e.toString()\n          })\n        }\n\n        resolve()\n      }),\n    onRowUpdate: newData =>\n      new Promise(async resolve => {\n        // check group\n        if (await checkGroup(newData.group)) {\n          return resolve()\n        }\n\n        try {\n          const db = await rxDb()\n\n          const query = db[collection]\n            .findOne()\n            .where(primary)\n            .eq(newData[primary])\n\n          await query.update({\n            $set: {\n              ...newData,\n              customized:\n                ((newData.customized as unknown) as string) === \"true\",\n              ...updated_at\n            }\n          })\n\n          // show notice\n          await notice({ title: `Updated successful` })\n        } catch (e) {\n          console.error(e)\n\n          // show notice\n          await notice({\n            title: `Updated failed`,\n            severity: \"error\",\n            content: e.toString()\n          })\n        }\n\n        resolve()\n      }),\n    onRowDelete: oldData =>\n      new Promise(async resolve => {\n        try {\n          const db = await rxDb()\n\n          const query = db[collection]\n            .findOne()\n            .where(primary)\n            .eq(oldData[primary])\n\n          await query.remove()\n\n          // show notice\n          await notice({ title: `Deleted successful` })\n        } catch (e) {\n          console.error(e)\n\n          // show notice\n          await notice({\n            title: `Deleted failed`,\n            severity: \"error\",\n            content: e.toString()\n          })\n        }\n\n        resolve()\n      })\n  }\n}\n"]},"metadata":{},"sourceType":"module"}