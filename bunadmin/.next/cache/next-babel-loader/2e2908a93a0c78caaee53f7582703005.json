{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport rxDb from \"@/utils/database/rxConnect\";\nimport { Collection } from \"../collections\";\nimport { Primary } from \"../schema\";\nexport function editableController() {\n  var collection = Collection.name;\n  var primary = Primary; // const nanoId = require(\"nanoid\")(10)\n  // const created_at = { created_at: Date.now() }\n\n  return {\n    // isEditable: rowData => rowData.not_editable === true, // only name(a) rows would be editable\n    // isDeletable: rowData => rowData.not_deletable === true, // only name(a) rows would be deletable\n    // onRowAdd: newData =>\n    //   new Promise(async resolve => {\n    //     try {\n    //       const db = await rxDb()\n    //\n    //       const severity = newData.severity\n    //         ? { severity: newData.severity }\n    //         : { severity: \"success\" }\n    //\n    //       await db[collection].insert({\n    //         ...newData,\n    //         [primary]: nanoId,\n    //         ...created_at,\n    //         ...severity\n    //       })\n    //     } catch (e) {\n    //       console.error(e)\n    //     }\n    //\n    //     resolve()\n    //   }),\n    // onRowUpdate: newData =>\n    //   new Promise(async resolve => {\n    //     try {\n    //       const db = await rxDb()\n    //\n    //       const query = db[collection]\n    //         .findOne()\n    //         .where(primary)\n    //         .eq(newData[primary])\n    //\n    //       await query.update({\n    //         $set: newData\n    //       })\n    //     } catch (e) {\n    //       console.error(e)\n    //     }\n    //\n    //     resolve()\n    //   }),\n    onRowDelete: function onRowDelete(oldData) {\n      return new Promise( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve) {\n          var db, query;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.prev = 0;\n                  _context.next = 3;\n                  return rxDb();\n\n                case 3:\n                  db = _context.sent;\n                  query = db[collection].findOne().where(primary).eq(oldData[primary]);\n                  _context.next = 7;\n                  return query.remove();\n\n                case 7:\n                  _context.next = 12;\n                  break;\n\n                case 9:\n                  _context.prev = 9;\n                  _context.t0 = _context[\"catch\"](0);\n                  console.error(_context.t0);\n\n                case 12:\n                  resolve();\n\n                case 13:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[0, 9]]);\n        }));\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    }\n  };\n}","map":{"version":3,"sources":["/Volumes/Untitled/GitHub/itanlam/ne/bunadmin/src/core/notice/controllers/editableController.tsx"],"names":["rxDb","Collection","Primary","editableController","collection","name","primary","onRowDelete","oldData","Promise","resolve","db","query","findOne","where","eq","remove","console","error"],"mappings":";;AAAA,OAAOA,IAAP,MAAiB,4BAAjB;AAGA,SAASC,UAAT,QAA2B,gBAA3B;AACA,SAASC,OAAT,QAAwB,WAAxB;AAEA,OAAO,SAASC,kBAAT,GAAsD;AAC3D,MAAMC,UAAU,GAAGH,UAAU,CAACI,IAA9B;AACA,MAAMC,OAAO,GAAGJ,OAAhB,CAF2D,CAI3D;AACA;;AAEA,SAAO;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAK,IAAAA,WAAW,EAAE,qBAAAC,OAAO;AAAA,aAClB,IAAIC,OAAJ;AAAA,4EAAY,iBAAMC,OAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBAESV,IAAI,EAFb;;AAAA;AAEFW,kBAAAA,EAFE;AAIFC,kBAAAA,KAJE,GAIMD,EAAE,CAACP,UAAD,CAAF,CACXS,OADW,GAEXC,KAFW,CAELR,OAFK,EAGXS,EAHW,CAGRP,OAAO,CAACF,OAAD,CAHC,CAJN;AAAA;AAAA,yBASFM,KAAK,CAACI,MAAN,EATE;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAWRC,kBAAAA,OAAO,CAACC,KAAR;;AAXQ;AAcVR,kBAAAA,OAAO;;AAdG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAZ;;AAAA;AAAA;AAAA;AAAA,UADkB;AAAA;AA3Cf,GAAP;AA6DD","sourcesContent":["import rxDb from \"@/utils/database/rxConnect\"\nimport { EditableDataType } from \"@/components/CommonTable/models/editable\"\nimport { Type } from \"../types\"\nimport { Collection } from \"../collections\"\nimport { Primary } from \"../schema\"\n\nexport function editableController(): EditableDataType<Type> {\n  const collection = Collection.name\n  const primary = Primary\n\n  // const nanoId = require(\"nanoid\")(10)\n  // const created_at = { created_at: Date.now() }\n\n  return {\n    // isEditable: rowData => rowData.not_editable === true, // only name(a) rows would be editable\n    // isDeletable: rowData => rowData.not_deletable === true, // only name(a) rows would be deletable\n    // onRowAdd: newData =>\n    //   new Promise(async resolve => {\n    //     try {\n    //       const db = await rxDb()\n    //\n    //       const severity = newData.severity\n    //         ? { severity: newData.severity }\n    //         : { severity: \"success\" }\n    //\n    //       await db[collection].insert({\n    //         ...newData,\n    //         [primary]: nanoId,\n    //         ...created_at,\n    //         ...severity\n    //       })\n    //     } catch (e) {\n    //       console.error(e)\n    //     }\n    //\n    //     resolve()\n    //   }),\n    // onRowUpdate: newData =>\n    //   new Promise(async resolve => {\n    //     try {\n    //       const db = await rxDb()\n    //\n    //       const query = db[collection]\n    //         .findOne()\n    //         .where(primary)\n    //         .eq(newData[primary])\n    //\n    //       await query.update({\n    //         $set: newData\n    //       })\n    //     } catch (e) {\n    //       console.error(e)\n    //     }\n    //\n    //     resolve()\n    //   }),\n    onRowDelete: oldData =>\n      new Promise(async resolve => {\n        try {\n          const db = await rxDb()\n\n          const query = db[collection]\n            .findOne()\n            .where(primary)\n            .eq(oldData[primary])\n\n          await query.remove()\n        } catch (e) {\n          console.error(e)\n        }\n\n        resolve()\n      })\n  }\n}\n"]},"metadata":{},"sourceType":"module"}